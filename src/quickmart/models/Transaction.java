package quickmart.models;

import quickmart.payment.PaymentMethods;
import quickmart.utils.DBUtil; // Keep this import

import java.sql.*; // Need this for SQLException, Timestamp, PreparedStatement, ResultSet
import java.io.IOException;
import java.util.Date;
import java.util.List;
import java.util.ArrayList; // Import needed for creating list copy
import java.text.NumberFormat; // For currency formatting

public class Transaction {
    private int transactionId; // Will be set AFTER insert by the database
    private Buyer buyer;
    private List<Item> items;
    private Date transactionDate;
    private PaymentMethods.PaymentStrategy paymentMethod;
    private double totalAmount;
    private boolean isSuccessful; // Represents PAYMENT success initially

    private static final NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance(); // For display

    /**
     * Creates a new Transaction, processes payment, and saves details to the database.
     * The transactionId is generated by the database AUTO_INCREMENT mechanism.
     *
     * @param buyer The buyer making the transaction. Cannot be null.
     * @param items The list of items being purchased. Cannot be null.
     * @param paymentMethod The payment strategy used. Cannot be null.
     * @throws IllegalArgumentException if buyer, items, or paymentMethod is null.
     * @throws RuntimeException if saving the transaction to the database fails critically.
     */
    public Transaction(Buyer buyer, List<Item> items, PaymentMethods.PaymentStrategy paymentMethod) {
        // Validate inputs
        if (buyer == null) throw new IllegalArgumentException("Buyer cannot be null.");
        if (items == null) throw new IllegalArgumentException("Items list cannot be null.");
        if (paymentMethod == null) throw new IllegalArgumentException("Payment method cannot be null.");

        // Initialize fields
        this.buyer = buyer;
        this.items = new ArrayList<>(items); // Create a defensive copy
        this.transactionDate = new Date();
        this.paymentMethod = paymentMethod;
        this.totalAmount = calculateTotalAmount(); // Calculate based on the *copied* list
        this.transactionId = 0; // Initialize ID to 0 (or -1) indicating not saved yet

        // 1. Simulate payment processing
        // Store the result of the payment attempt directly
        boolean paymentProcessingSuccess = paymentMethod.processPayment(this.totalAmount);
        this.isSuccessful = paymentProcessingSuccess; // Store initial payment status
        System.out.println("DEBUG: Payment processing simulation result: " + this.isSuccessful);

        // 2. Attempt to save to Database (even if payment failed, to potentially record attempts)
        boolean savedToDb = false;
        // Only proceed to save if payment was successful? Optional - depends on requirements.
        // Current logic saves regardless but marks overall success based on both.
        // if (this.isSuccessful) { // Optionally only save if payment worked
            try {
                saveToDatabase(); // This method will set this.transactionId if successful
                if (this.transactionId > 0) {
                    savedToDb = true; // Mark DB save as successful
                    System.out.println("DEBUG: Transaction details saved to database with generated ID: " + this.transactionId);
                } else {
                    // This case implies saveToDatabase failed to get an ID even without throwing SQLException
                    System.err.println("ERROR: Transaction saved to DB, but failed to retrieve generated ID.");
                    savedToDb = false;
                }
            } catch (SQLException | IOException e) {
                // Log the critical error
                System.err.println("CRITICAL DATABASE ERROR: Failed to save transaction (BuyerID: " + buyer.getUserId() + "): " + e.getMessage());
                savedToDb = false; // Mark DB save as failed
                e.printStackTrace();
                // It might be appropriate to wrap and rethrow as a runtime exception here
                // to clearly signal that the transaction could not be persisted.
                // throw new RuntimeException("Failed to save transaction due to database error.", e);
            }
        // } else {
        //     System.out.println("DEBUG: Skipping database save because payment processing failed.");
        // }

        // Determine final success status based on BOTH payment and DB save
        this.isSuccessful = paymentProcessingSuccess && savedToDb;

        if (!this.isSuccessful) {
             System.err.println("Transaction marked as FAILED overall (Payment Success: " + paymentProcessingSuccess + ", DB Save Success: " + savedToDb + ")");
        } else {
             System.out.println("Transaction marked as SUCCESSFUL overall.");
        }
    }

    Transaction(int nextTransactionId, Buyer buyer, List<Item> items, PaymentMethods.PaymentStrategy paymentStrategy) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    /**
     * Handles saving the transaction header and items to the database
     * using JDBC transactions and retrieving the auto-generated ID.
     * This method sets the `this.transactionId` field upon successful insertion.
     *
     * @throws SQLException If a database access error occurs during the transaction.
     * @throws IOException If getting the database connection fails.
     */
    private void saveToDatabase() throws SQLException, IOException {
        Connection conn = null;
        PreparedStatement pstmtTransaction = null;
        PreparedStatement pstmtItems = null;
        ResultSet generatedKeys = null;

        // SQL statement for inserting into Transactions, excluding transactionId
        String insertTransactionSql = "INSERT INTO Transactions (buyerId, transactionDate, totalAmount, paymentMethodType, paymentDetails, isSuccessful) VALUES (?, ?, ?, ?, ?, ?)";
        // SQL statement for inserting transaction items
        String insertTransactionItemsSql = "INSERT INTO TransactionItems (transactionId, itemId, quantity) VALUES (?, ?, ?)";

        // Determine payment details string
        String paymentMethodType = getPaymentMethodTypeInternal(); // Use internal helper
        String paymentDetails = getPaymentDetailsInternal();     // Use internal helper

        try {
            conn = DBUtil.getConnection();
            // --- Start JDBC Transaction ---
            conn.setAutoCommit(false);
            System.out.println("DEBUG: saveToDatabase - JDBC auto-commit disabled.");

            // 1. Insert into Transactions table
            System.out.println("DEBUG: saveToDatabase - Preparing statement for Transactions INSERT...");
            pstmtTransaction = conn.prepareStatement(insertTransactionSql, Statement.RETURN_GENERATED_KEYS);
            pstmtTransaction.setInt(1, this.buyer.getUserId());
            pstmtTransaction.setTimestamp(2, new Timestamp(this.transactionDate.getTime()));
            pstmtTransaction.setDouble(3, this.totalAmount);
            pstmtTransaction.setString(4, paymentMethodType);
            pstmtTransaction.setString(5, paymentDetails);
            pstmtTransaction.setBoolean(6, this.isSuccessful); // Save the *payment* success status

            System.out.println("DEBUG: saveToDatabase - Executing Transactions INSERT...");
            int affectedRows = pstmtTransaction.executeUpdate();

            if (affectedRows == 0) {
                 throw new SQLException("Creating transaction header failed, no rows affected."); // Will trigger rollback
            }
            System.out.println("DEBUG: saveToDatabase - Transactions INSERT successful (" + affectedRows + " row affected).");

            // 2. Get the auto-generated transactionId
            generatedKeys = pstmtTransaction.getGeneratedKeys();
            if (generatedKeys.next()) {
                this.transactionId = generatedKeys.getInt(1); // Set the ID on this object
                System.out.println("DEBUG: saveToDatabase - Retrieved generated Transaction ID: " + this.transactionId);
            } else {
                 throw new SQLException("Creating transaction header failed, no ID obtained."); // Will trigger rollback
            }
            // It's crucial to close the generatedKeys ResultSet promptly
             if (generatedKeys != null) try { generatedKeys.close(); } catch (SQLException e) { /* ignore */ }


            // 3. Insert into TransactionItems table (only if items exist and header insert succeeded)
            if (this.items != null && !this.items.isEmpty()) {
                System.out.println("DEBUG: saveToDatabase - Preparing statement for TransactionItems INSERT batch...");
                pstmtItems = conn.prepareStatement(insertTransactionItemsSql);
                for (Item item : this.items) {
                     if (item == null) continue; // Skip null items if they somehow got in the list
                    pstmtItems.setInt(1, this.transactionId); // Use the generated ID
                    pstmtItems.setInt(2, item.getItemId());
                    pstmtItems.setInt(3, 1); // Assuming quantity is always 1
                    pstmtItems.addBatch();
                     // System.out.println("DEBUG: Added Item ID " + item.getItemId() + " to batch for Transaction ID " + this.transactionId); // Verbose
                }
                 System.out.println("DEBUG: saveToDatabase - Executing TransactionItems INSERT batch for " + this.items.size() + " items...");
                int[] batchResults = pstmtItems.executeBatch();
                 System.out.println("DEBUG: saveToDatabase - TransactionItems batch execution finished. Results length: " + batchResults.length);
                 // Basic check: Ensure all items were inserted
                 if(batchResults.length != this.items.size()) {
                     // This check might be too simple if some inserts could legitimately fail in batch mode
                     System.err.println("WARN: TransactionItems batch insert count (" + batchResults.length + ") doesn't match item count (" + this.items.size() + ").");
                 }
                 // More robust check would iterate through batchResults
                 for(int result : batchResults) {
                     if (result == Statement.EXECUTE_FAILED) {
                         throw new SQLException("One or more TransactionItems failed to insert in batch."); // Will trigger rollback
                     }
                 }

            } else {
                 System.out.println("DEBUG: saveToDatabase - No items in the cart to insert into TransactionItems.");
            }


            // 4. Commit JDBC Transaction if all steps succeeded
            conn.commit();
            System.out.println("DEBUG: saveToDatabase - JDBC transaction committed successfully for Transaction ID: " + this.transactionId);

        } catch (SQLException e) {
            System.err.println("ERROR: SQLException during saveToDatabase for Transaction (BuyerID: " + buyer.getUserId() + "). Rolling back transaction.");
            e.printStackTrace(); // Print stack trace for SQL errors
            if (conn != null) {
                try {
                    conn.rollback(); // Rollback on any SQL error during the process
                    System.err.println("DEBUG: JDBC transaction rolled back successfully.");
                } catch (SQLException ex) {
                    System.err.println("ERROR: Failed to rollback JDBC transaction: " + ex.getMessage());
                }
            }
            this.transactionId = 0; // Ensure ID is reset if save fails
            // Re-throw the original exception to indicate failure up the call stack
            throw e;
        } finally {
            // Clean up resources (close statements, reset auto-commit)
            // Close generatedKeys ResultSet if it wasn't closed earlier (should be)
            if (generatedKeys != null && !generatedKeys.isClosed()) try { generatedKeys.close(); } catch (SQLException e) { /* ignore */ }
            if (pstmtTransaction != null) try { pstmtTransaction.close(); System.out.println("DEBUG: Closed pstmtTransaction."); } catch (SQLException e) { /* ignore */ }
            if (pstmtItems != null) try { pstmtItems.close(); System.out.println("DEBUG: Closed pstmtItems."); } catch (SQLException e) { /* ignore */ }
            if (conn != null) {
                try {
                    conn.setAutoCommit(true); // Reset auto-commit for the connection pool
                    System.out.println("DEBUG: saveToDatabase - JDBC auto-commit re-enabled.");
                } catch (SQLException e) {
                     System.err.println("ERROR: Failed to reset auto-commit: " + e.getMessage());
                }
                // DO NOT close the shared connection from DBUtil here.
            }
        }
    }


    private double calculateTotalAmount() {
        double total = 0;
        if (this.items != null) {
            for (Item item : this.items) {
                 if (item != null) {
                    total += item.getPrice();
                 }
            }
        }
        // Round to 2 decimal places to avoid potential floating point issues
        return Math.round(total * 100.0) / 100.0;
    }

    // Helper to get payment method type string
    private String getPaymentMethodTypeInternal() {
         if (paymentMethod == null) return "Unknown";
         // Use simple name for storage, e.g., "CashPayment" or "OnlinePayment"
         return paymentMethod.getClass().getSimpleName();
    }

    // Helper to get non-sensitive payment details string
    private String getPaymentDetailsInternal() {
        if (paymentMethod instanceof PaymentMethods.OnlinePayment) {
             // Avoid storing sensitive data. Indicate type or gateway reference.
             return "Online Payment Processed";
        } else if (paymentMethod instanceof PaymentMethods.CashPayment) {
             return "Cash Payment";
        }
        return "N/A";
    }


    // --- Public Getters ---
    public int getTransactionId() {
        // Returns the DB-generated ID (or 0 if save failed)
        return transactionId;
    }

    public Buyer getBuyer() {
        return buyer;
    }

    public List<Item> getItems() {
        // Return a defensive copy to prevent external modification
        return new ArrayList<>(items);
    }

    public Date getTransactionDate() {
        // Date object is mutable, return a copy for safety
        return new Date(transactionDate.getTime());
    }

    /**
     * Gets a user-friendly string representing the payment method type.
     * @return String like "CashPayment" or "OnlinePayment".
     */
    public String getPaymentMethodType() {
         return getPaymentMethodTypeInternal();
    }

    public double getTotalAmount() {
        return totalAmount;
    }

    /**
     * Checks if the transaction was successful BOTH in terms of payment processing
     * AND being successfully saved to the database (indicated by transactionId > 0).
     * @return true if both payment processing succeeded and database save succeeded, false otherwise.
     */
    public boolean isSuccessful() {
        // The transaction is considered successful overall only if
        // the initial payment processing was successful AND
        // the transaction was saved to the database (indicated by a positive ID).
        return this.isSuccessful && (this.transactionId > 0);
    }

    // --- displayTransactionDetails (for console debugging/logging) ---
    public void displayTransactionDetails() {
        System.out.println("\n--- Transaction Details ---");
        System.out.println("Transaction ID: " + (transactionId > 0 ? transactionId : "(Save Failed/Incomplete)"));
        System.out.println("Buyer: " + (buyer != null ? buyer.getName() + " (ID: " + buyer.getUserId() + ")" : "N/A"));
        System.out.println("Transaction Date: " + transactionDate);
        System.out.println("Total Amount: " + currencyFormatter.format(totalAmount));
        System.out.println("Payment Method: " + getPaymentMethodType());
        System.out.println("Payment Processed Status: " + this.isSuccessful); // Show initial payment status
        System.out.println("Database Save Status: " + (this.transactionId > 0 ? "Successful" : "Failed"));
        System.out.println("Overall Status: " + (isSuccessful() ? "Successful" : "Failed")); // Use the combined success check

        if (isSuccessful()) {
            System.out.println("✅ Transaction completed and saved!");
        } else {
            System.out.println("❌ Transaction failed or could not be saved properly.");
        }
         System.out.println("Items Purchased:");
         if (items != null && !items.isEmpty()) {
             for (Item item : items) {
                  if (item != null) {
                    System.out.println("  - " + item.getTitle() + " (ID: " + item.getItemId() + ") | Price: " + currencyFormatter.format(item.getPrice()));
                  }
             }
         } else {
              System.out.println("  (No items listed for this transaction object)");
         }
         System.out.println("------------------------------");
    }
}